<html>

<head>
<title>Dice Roller</title>
<style>
    body {
        font-family: Arial, sans-serif;
        margin: 0;
        padding: 0;
        background-color: #f0f0f0;
    }

    :root {
        box-sizing: border-box;
    }
</style>
</head>

<body>
    <dice-roller></dice-roller>
    <!-- <script src="./dicepanel.js"></script> -->
    <script>
        class DragGrip extends HTMLElement {
            constructor() {
                super();
                this.isDragging = false;
                this.initialMousePosition = { x: 0, y: 0 };
                this.initialParentPosition = { x: 0, y: 0 };
            }

            connectedCallback() {
                this.setStyle();
                this.attachDragListeners();
            }

            setStyle() {
                Object.assign(this.style, {
                    cursor: 'grab',
                    display: 'inline-flex',
                    backgroundColor: 'skyblue',
                    padding: '0.1rem',
                    userSelect: 'none',
                    position: 'absolute',
                    top: '0',
                    left: '0',
                    width: '0.9rem',
                    height: '0.9rem',
                    fontSize: '0.75rem'
                });
                this.textContent = '‚Åõ';
                const parent = this.parentElement;
                if (parent) parent.style.position = 'absolute';
            }

            attachDragListeners() {
                this.addEventListener('mousedown', this.onMouseDown.bind(this));
                document.addEventListener('mousemove', this.onMouseMove.bind(this));
                document.addEventListener('mouseup', this.onMouseUp.bind(this));
            }

            onMouseDown(e) {
                this.isDragging = true;
                this.initialMousePosition = { x: e.clientX, y: e.clientY };
                this.style.cursor = 'grabbing';

                const parent = this.parentElement;
                if (parent) {
                    this.initialParentPosition = { x: parent.offsetLeft, y: parent.offsetTop };
                }
                e.preventDefault(); // Prevent text selection
            }

            onMouseMove(e) {
                if (!this.isDragging) return;

                const deltaX = e.clientX - this.initialMousePosition.x;
                const deltaY = e.clientY - this.initialMousePosition.y;
                const newX = this.initialParentPosition.x + deltaX;
                const newY = this.initialParentPosition.y + deltaY;

                const parent = this.parentElement;
                if (parent) {
                    parent.style.left = `${newX}px`;
                    parent.style.top = `${newY}px`;
                }
            }

            onMouseUp() {
                if (this.isDragging) {
                    this.isDragging = false;
                    this.style.cursor = 'grab';
                }
            }
        }

        class DiceRoller extends HTMLElement {
            constructor() {
                super();
                const shadow = this.attachShadow({ mode: 'open' });

                // Create the container for the dice
                const container = document.createElement('div');
                container.setAttribute('id', 'dice-container');
                container.innerHTML = `
            <div id="titlebar" class="titlebar">
                <div id="drag-grip" class="grip">‚Åû‚Åû</div>
                <span id="title">Dice Roller</span>
                <button id="minimize-button">‚Äî</button>
                <button id="maximize-button">üóñ</button>
                <button id="close-button">‚úï</button>
            </div>

            <div id="dice-controls">                        <div id="webgl-output"></div>

                <br/><hr/>
                <label for="dice-type">Choose Dice Type:</label>
                <select id="dice-type">
                    <option value="4">D4</option>
                    <option value="6">D6</option>
                    <option value="8">D8</option>
                    <option value="10">D10</option>
                    <option value="12">D12</option>
                    <option value="20">D20</option>
                    <option value="100">D100</option>
                </select>
                <label for="dice-count">How many dice?</label>
                <input type="number" id="dice-count" min="1" max="10" value="1">
                <button id="roll-button">üé≤ Roll Dice</button>
            </div>
            <div id="result"></div>
        `;

                const style = document.createElement('style');
                style.textContent = `
            /* Container Styling */
            #dice-container {
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                perspective: 1000px;
                position: absolute; /* Ensure the container can be positioned */
                top: 100px;
                left: 100px;
                width: 650px;
                background-color: #f0f0f0;
                border: 2px solid #ccc;
                border-radius: 10px;
                box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
                overflow: hidden;
                transition: all 0.3s ease;
            }

            /* WebGL Output Styling */
            #webgl-output {
                width: 600px;
                height: 400px;
            }

            /* Titlebar Styling */
            .titlebar {
                background-color: #2c3e50;
                padding: 5px;
                display: flex;
                align-items: center;
                width: 100%;
                cursor: move;
                user-select: none;
                position: relative;
                box-sizing: border-box;
            }

            #drag-grip {
                margin-right: 10px;
                font-size: 1.2rem;
                color: white;
            }

            #title {
                flex-grow: 1;
                text-align: center;
                font-size: 1.1rem;
                font-weight: bold;
                color: white;
                text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
            }

            .titlebar button {
                background-color: #ffffff29;
                border: 1px outset #ffffff99;
                color: purple;
                cursor: pointer;
                font-size: 1rem;
                padding: 3px 6px;
                margin-left: 5px;
                border-radius: 3px;
                transition: background-color 0.3s;
            }

            .titlebar button:hover {
                background-color: #00000009;
            }

            .titlebar button:active {
                background-color: #34495e;
            }

            /* Dice Controls Styling */
            #dice-controls {
                margin-top: 20px;
                text-align: center;
            }

            #roll-button {
                padding: 10px 20px;
                margin-left: 10px;
                cursor: pointer;
                border: none;
                background-color: #ff6666;
                color: white;
                font-size: 16px;
                font-weight: bold;
                border-radius: 10px;
                transition: background-color 0.3s;
            }

            #roll-button:hover {
                background-color: #ff4d4d;
            }

            /* Result Display Styling */
            #result {
                margin-top: 10px;
                font-size: 24px;
                color: #333333;
            }

            /* Animations */
            .fade-in {
                animation: fadeIn 1s forwards;
            }

            .slide-in {
                animation: slideIn 1s forwards;
            }

            @keyframes fadeIn {
                from {
                    opacity: 0;
                }
                to {
                    opacity: 1;
                }
            }

            @keyframes slideIn {
                from {
                    transform: translateY(100%);
                }
                to {
                    transform: translateY(0);
                }
            }

            /* Scrollbar Styling */
            ::-webkit-scrollbar {
                width: 10px;
            }

            ::-webkit-scrollbar-track {
                background: #2c3e50;
            }

            ::-webkit-scrollbar-thumb {
                background: #34495e;
                border-radius: 5px;
            }

            ::-webkit-scrollbar-thumb:hover {
                background: #4a6278;
            }
        `;

                shadow.appendChild(style);
                shadow.appendChild(container);
                container.classList.add('slide-in');
                this.container = container;

                // Initialize properties
                this.diceMeshes = [];
                this.diceBodies = [];
                this.diceValues = [];
                this.animationFrameId = null;

                // Initialize drag functionality
                this.initDragGrip();
            }

            connectedCallback() {
                this.loadScripts()
                    .then(() => {
                        this.initializeDiceRoller();
                    })
                    .catch(error => console.error('Failed to load libraries:', error));
            }

            /**
             * Dynamically load external scripts (Three.js and Cannon.js)
             */
            loadScripts() {
                return new Promise((resolve, reject) => {
                    // Load Three.js
                    const threeScript = document.createElement('script');
                    threeScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js';
                    threeScript.onload = () => {
                        // Load Cannon.js after Three.js has been loaded
                        const cannonScript = document.createElement('script');
                        cannonScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js';
                        cannonScript.onload = resolve;
                        cannonScript.onerror = reject;
                        this.shadowRoot.appendChild(cannonScript);
                    };
                    threeScript.onerror = reject;
                    this.shadowRoot.appendChild(threeScript);
                });
            }

            /**
             * Initialize the Dice Roller after scripts are loaded
             */
            initializeDiceRoller() {
                // Get DOM elements
                const rollButton = this.shadowRoot.getElementById('roll-button');
                const diceTypeSelect = this.shadowRoot.getElementById('dice-type');
                const diceCountInput = this.shadowRoot.getElementById('dice-count');
                const closeButton = this.shadowRoot.getElementById('close-button');
                const minimizeButton = this.shadowRoot.getElementById('minimize-button');
                const maximizeButton = this.shadowRoot.getElementById('maximize-button');

                // Add event listeners
                rollButton.addEventListener('click', () => this.rollDice());
                diceTypeSelect.addEventListener('change', () => {
                    this.createDice(parseInt(diceTypeSelect.value), parseInt(diceCountInput.value));
                });
                diceCountInput.addEventListener('change', () => {
                    this.createDice(parseInt(diceTypeSelect.value), parseInt(diceCountInput.value));
                });
                closeButton.addEventListener('click', () => this.closePanel());
                minimizeButton.addEventListener('click', () => this.minimizePanel());
                maximizeButton.addEventListener('click', () => this.maximizePanel());

                // Initialize Three.js and Cannon.js
                this.initThreeJS();
                this.initCannonJS();

                // Create initial dice
                this.createDice(parseInt(diceTypeSelect.value), parseInt(diceCountInput.value));
            }

            /**
             * Initialize Three.js components
             */
            initThreeJS() {
                // Three.js scene setup
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, 600 / 400, 0.1, 1000);
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(600, 400);
                const webglOutput = this.shadowRoot.getElementById('webgl-output');
                webglOutput.innerHTML = ''; // Clear previous renderer
                webglOutput.appendChild(this.renderer.domElement);

                // Add lights
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
                this.scene.add(ambientLight);
                const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
                directionalLight.position.set(5, 10, 7.5);
                this.scene.add(directionalLight);

                // Position the camera
                this.camera.position.z = 10;

                // Update camera position based on dice count
                const diceCountInput = this.shadowRoot.getElementById('dice-count');
                diceCountInput.addEventListener('change', () => {
                    const diceCount = parseInt(diceCountInput.value);
                    this.camera.position.y = 10 + (diceCount - 1) * 2; // Adjust y based on dice count
                    this.camera.lookAt(0, 0, 0);
                });

                this.camera.lookAt(0, 0, 0);
            }

            /**
             * Initialize Cannon.js physics world
             */
            initCannonJS() {
                // Initialize Cannon.js world
                this.world = new CANNON.World();
                this.world.gravity.set(0, -9.82, 0); // Earth gravity

                // Broadphase
                this.world.broadphase = new CANNON.NaiveBroadphase();
                this.world.solver.iterations = 10;

                // Add a floor plane
                const groundMaterial = new CANNON.Material();
                const groundShape = new CANNON.Plane();
                const groundBody = new CANNON.Body({ mass: 0, material: groundMaterial });
                groundBody.addShape(groundShape);
                groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
                this.world.addBody(groundBody);
            }

            /**
             * Reset the scene by removing existing dice and bodies
             */
            resetScene() {
                // Remove existing dice meshes and bodies from the scene
                this.diceMeshes.forEach(mesh => this.scene.remove(mesh));
                this.diceBodies.forEach(body => this.world.removeBody(body));
                this.diceMeshes = [];
                this.diceBodies = [];
                this.diceValues = [];

                // Cancel any ongoing animation frame
                if (this.animationFrameId) {
                    cancelAnimationFrame(this.animationFrameId);
                    this.animationFrameId = null;
                }
            }

            /**
             * Create dice based on type and count
             * @param {number} sides - Number of sides on the dice
             * @param {number} count - Number of dice to create
             */
            createDice(sides, count = 1) {
                this.resetScene();

                for (let i = 0; i < count; i++) {
                    let geometry, shape, faceLabels;

                    // Determine geometry and shape based on dice type
                    switch (sides) {
                        case 4:
                            geometry = this.createD4Geometry();
                            shape = this.createConvexShape(geometry);
                            faceLabels = ['1', '2', '3', '4'];
                            break;
                        case 6:
                            geometry = this.createD6Geometry();
                            shape = new CANNON.Box(new CANNON.Vec3(0.5, 0.5, 0.5));
                            faceLabels = ['1', '2', '3', '4', '5', '6'];
                            break;
                        case 8:
                            geometry = this.createD8Geometry();
                            shape = this.createConvexShape(geometry);
                            faceLabels = ['1', '2', '3', '4', '5', '6', '7', '8'];
                            break;
                        case 10:
                            geometry = this.createD10Geometry();
                            shape = this.createConvexShape(geometry);
                            faceLabels = Array.from({ length: 10 }, (_, i) => `${i + 1}`);
                            break;
                        case 12:
                            geometry = this.createD12Geometry();
                            shape = this.createConvexShape(geometry);
                            faceLabels = Array.from({ length: 12 }, (_, i) => `${i + 1}`);
                            break;
                        case 20:
                            geometry = this.createD20Geometry();
                            shape = this.createConvexShape(geometry);
                            faceLabels = Array.from({ length: 20 }, (_, i) => `${i + 1}`);
                            break;
                        case 100:
                            geometry = this.createD100Geometry();
                            shape = this.createConvexShape(geometry);
                            faceLabels = Array.from({ length: 100 }, (_, i) => `${i + 1}`);
                            break;
                        default:
                            geometry = this.createD6Geometry();
                            shape = new CANNON.Box(new CANNON.Vec3(0.5, 0.5, 0.5));
                            faceLabels = ['1', '2', '3', '4', '5', '6'];
                    }

                    // Create materials with face labels
                    const materials = this.createFaceMaterials(geometry, faceLabels, sides);

                    // Create Three.js mesh
                    const diceMesh = new THREE.Mesh(geometry, materials);
                    diceMesh.userData.faceLabels = faceLabels;
                    this.scene.add(diceMesh);

                    // Create Cannon.js body
                    const diceBody = new CANNON.Body({ mass: 1, shape: shape });
                    diceBody.position.set(Math.random() * 2 - 1, 2 + i * 2, Math.random() * 2 - 1); // Random start positions
                    diceBody.quaternion.set(Math.random(), Math.random(), Math.random(), Math.random());
                    diceBody.quaternion.normalize();
                    diceBody.angularDamping = 0.1;
                    diceBody.linearDamping = 0.1;
                    this.world.addBody(diceBody);

                    // Store references
                    this.diceMeshes.push(diceMesh);
                    this.diceBodies.push(diceBody);
                    this.diceValues.push({ sides: sides, value: Math.floor(Math.random() * sides) + 1 });
                }
            }

            // Create face materials with number textures
            createFaceMaterials(geometry, faceLabels, sides) {
                const materials = [];
                const numFaces = sides;

                for (let i = 0; i < numFaces; i++) {
                    const label = faceLabels[i % faceLabels.length];

                    const canvas = document.createElement('canvas');
                    canvas.width = 256;
                    canvas.height = 256;
                    const context = canvas.getContext('2d');

                    // Background
                    context.fillStyle = '#ffffff';
                    context.fillRect(0, 0, canvas.width, canvas.height);

                    // Text
                    context.fillStyle = '#000000';
                    context.font = 'bold 150px Arial';
                    context.textAlign = 'center';
                    context.textBaseline = 'middle';
                    context.fillText(label, canvas.width / 2, canvas.height / 2);

                    // Create texture from canvas
                    const texture = new THREE.CanvasTexture(canvas);
                    materials.push(new THREE.MeshBasicMaterial({ map: texture }));
                }

                geometry.clearGroups();
                for (let i = 0; i < numFaces; i++) {
                    geometry.addGroup(i * 3, 3, i);
                }

                return materials;
            }

            /**
             * Convert Three.js geometry to Cannon.js ConvexPolyhedron
             * @param {THREE.Geometry} geometry - The geometry to convert
             * @returns {CANNON.ConvexPolyhedron} - The ConvexPolyhedron shape
             */
            createConvexShape(geometry) {
                // Converts a Three.js BufferGeometry to a Cannon.js ConvexPolyhedron shape
                const positionAttribute = geometry.attributes.position;
                const vertices = [];
                const faces = [];

                for (let i = 0; i < positionAttribute.count; i++) {
                    vertices.push(new CANNON.Vec3(
                        positionAttribute.getX(i),
                        positionAttribute.getY(i),
                        positionAttribute.getZ(i)
                    ));
                }

                if (geometry.index) {
                    const indices = geometry.index.array;
                    for (let i = 0; i < indices.length; i += 3) {
                        faces.push([indices[i], indices[i + 1], indices[i + 2]]);
                    }
                } else {
                    for (let i = 0; i < positionAttribute.count; i += 3) {
                        faces.push([i, i + 1, i + 2]);
                    }
                }

                return new CANNON.ConvexPolyhedron(vertices, faces);
            }

            /**
             * Roll the dice by applying random velocities
             */
            rollDice() {
                const diceCount = parseInt(this.shadowRoot.getElementById('dice-count').value, 10);
                const diceType = parseInt(this.shadowRoot.getElementById('dice-type').value, 10);

                this.createDice(diceType, diceCount); // Recreate dice with the selected type and count

                // Apply random velocity and angular velocity for realistic dice roll
                this.diceBodies.forEach(diceBody => {
                    diceBody.velocity.set(
                        0,
                        (Math.random() + 1) * 5,
                        0
                    );
                    diceBody.angularVelocity.set(
                        (Math.random() + 1) * 20,
                        (Math.random() + 1) * 20,
                        (Math.random() + 1) * 20
                    );
                    diceBody.angularDamping = 0.1;
                    diceBody.linearDamping = 0.1;
                    diceBody.sleepThreshold = 0.1;
                    diceBody.sleepSpeedLimit = 0.1;
                });

                this.updatePhysics();
            }

            /**
             * Update physics and render the scene
             */
            updatePhysics() {
                const timeStep = 1 / 60;
                let lastTime;
                const maxSimulationTime = 10000; // Max simulation time in ms
                const startTime = performance.now();

                const update = (time) => {
                    if (!lastTime) lastTime = time;
                    const delta = (time - lastTime) / 1000;
                    lastTime = time;

                    // Limit simulation time
                    if (time - startTime > maxSimulationTime) {
                        this.getDiceResult();
                        return;
                    }

                    this.world.step(timeStep, delta, 3);

                    // Update Three.js mesh positions and rotations from Cannon.js physics
                    this.diceBodies.forEach((diceBody, i) => {
                        this.diceMeshes[i].position.copy(diceBody.position);
                        this.diceMeshes[i].quaternion.copy(diceBody.quaternion);
                    });

                    this.renderer.render(this.scene, this.camera);
                    this.animationFrameId = requestAnimationFrame(update);
                    this.camera.position.x = this.diceBodies[0].position.x;
                    // Check if dice have stopped moving
                    if (this.diceBodies.every(body => body.sleepState === CANNON.Body.SLEEPING)) {
                        this.getDiceResult();
                    }
                };

                this.animationFrameId = requestAnimationFrame(update);
            }

            /**
             * Calculate and display the result based on dice orientation
             */
            getDiceResult() {
                let totalResult = 0;

                this.diceBodies.forEach((diceBody, index) => {
                    const result = this.calculateResultFromQuaternion(
                        this.diceValues[index].sides,
                        diceBody.quaternion,
                        index
                    );
                    if (result !== null) { // Ensure result is valid
                        this.diceValues[index].value = result;
                        totalResult += result;
                    } else {
                        // Fallback in case of calculation failure
                        this.diceValues[index].value = Math.floor(Math.random() * this.diceValues[index].sides) + 1;
                    }
                });

                const individualResults = this.diceValues.map(d => d.value).join(', ');
                totalResult = 0;
                Array.from(individualResults.split(', ')).forEach((result, index) => {
                    totalResult += parseInt(result, 10);
                });
                this.shadowRoot.getElementById('result').textContent = `Result: ${individualResults} (Total: ${totalResult})`;
            }

            /**
             * Determine the result of a dice based on its final orientation
             * @param {number} sides - Number of sides on the dice
             * @param {CANNON.Quaternion} quaternion - The final quaternion of the dice
             * @param {number} index - Index of the dice
             * @returns {number|null} - The result value or null if undetermined
             */
            calculateResultFromQuaternion(sides, quaternion, index) {
                // For each dice type, determine the face that is upwards
                const upVector = new THREE.Vector3(0, 1, 0);
                const diceMesh = this.diceMeshes[index];

                let maxDot = -Infinity;
                let faceIndex = -1;

                const positionAttribute = diceMesh.geometry.attributes.position;
                const indexAttribute = diceMesh.geometry.index;
                const faceNormals = [];

                if (indexAttribute) {
                    const indices = indexAttribute.array;
                    for (let i = 0; i < indices.length; i += 3) {
                        const a = indices[i];
                        const b = indices[i + 1];
                        const c = indices[i + 2];

                        const vertexA = new THREE.Vector3(
                            positionAttribute.getX(a),
                            positionAttribute.getY(a),
                            positionAttribute.getZ(a)
                        );
                        const vertexB = new THREE.Vector3(
                            positionAttribute.getX(b),
                            positionAttribute.getY(b),
                            positionAttribute.getZ(b)
                        );
                        const vertexC = new THREE.Vector3(
                            positionAttribute.getX(c),
                            positionAttribute.getY(c),
                            positionAttribute.getZ(c)
                        );

                        // Compute the face normal
                        const edge1 = new THREE.Vector3().subVectors(vertexB, vertexA);
                        const edge2 = new THREE.Vector3().subVectors(vertexC, vertexA);
                        const normal = new THREE.Vector3().crossVectors(edge1, edge2).normalize();

                        normal.applyQuaternion(quaternion);

                        faceNormals.push(normal);
                    }
                }

                // Find the face most aligned with the up vector
                for (let i = 0; i < faceNormals.length; i++) {
                    const dot = faceNormals[i].dot(upVector);
                    if (dot > maxDot) {
                        maxDot = dot;
                        faceIndex = i;
                    }
                }

                if (faceIndex === -1) {
                    console.warn(`Could not determine face for dice index ${index}`);
                    return null;
                }

                // Get the dice value from faceLabels
                const faceLabels = diceMesh.userData.faceLabels;
                if (!faceLabels || faceIndex >= faceLabels.length) {
                    console.warn(`Invalid face index ${faceIndex} for dice index ${index}`);
                    return null;
                }

                let value = faceLabels[faceIndex];

                // Additional check for D100 to ensure valid parsing
                if (sides === 100) {
                    // For D100, it's common to roll two D10 dice: one for tens and one for units.
                    // Here, we'll assume each D100 face represents a unique number from 1 to 100.
                    // Adjust as needed based on your design.
                    value = faceLabels[faceIndex];
                }

                const parsedValue = parseInt(value, 10);
                if (isNaN(parsedValue)) {
                    console.warn(`Parsed value is NaN for face index ${faceIndex} on dice index ${index}`);
                    return null;
                }

                return parsedValue;
            }

            /**
             * Create custom geometry for D4 dice
             * @returns {THREE.BufferGeometry} - The D4 geometry
             */
            createD4Geometry() {
                const geometry = new THREE.BufferGeometry();
                const vertices = new Float32Array([
                    // Vertex coordinates for a tetrahedron
                    1, 1, 1,
                    -1, -1, 1,
                    -1, 1, -1,
                    1, -1, -1
                ]);

                const indices = [
                    0, 2, 1,
                    0, 1, 3,
                    0, 3, 2,
                    1, 2, 3
                ];

                // UV coordinates mapped per face
                const uvs = [
                    // Each face has its own UV mapping
                    0.5, 1, 0, 0, 1, 0,  // Face 1
                    0.5, 1, 0, 0, 1, 0,  // Face 2
                    0.5, 1, 0, 0, 1, 0,  // Face 3
                    0.5, 1, 0, 0, 1, 0   // Face 4
                ];

                geometry.setIndex(indices);
                geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
                geometry.setAttribute('uv', new THREE.BufferAttribute(new Float32Array(uvs.flat()), 2));
                geometry.computeVertexNormals();

                return geometry;
            }

            /**
             * Create custom geometry for D6 dice (standard cube)
             * @returns {THREE.BoxGeometry} - The D6 geometry
             */
            createD6Geometry() {
                return new THREE.BoxGeometry(1, 1, 1);
            }

            /**
             * Create custom geometry for D8 dice (octahedron)
             * @returns {THREE.OctahedronGeometry} - The D8 geometry
             */
            createD8Geometry() {
                return new THREE.OctahedronGeometry(1);
            }

            /**
             * Create custom geometry for D10 dice (pentagonal trapezohedron)
             * @returns {THREE.BufferGeometry} - The D10 geometry
             */
            createD10Geometry() {
                const geometry = new THREE.BufferGeometry();
                const angle = Math.PI / 5; // 36 degrees
                const height = 1;
                const radius = Math.sqrt(2) / 2; // Radius to ensure unit length edges

                const vertices = [];
                const indices = [];
                const uvs = [];

                // Create top and bottom vertices
                for (let i = 0; i < 10; i++) {
                    const theta = i * 2 * angle;
                    const z = height / 2;
                    vertices.push(
                        radius * Math.cos(theta),
                        radius * Math.sin(theta),
                        z
                    );
                }
                for (let i = 0; i < 10; i++) {
                    const theta = i * 2 * angle + angle;
                    const z = -height / 2;
                    vertices.push(
                        radius * Math.cos(theta),
                        radius * Math.sin(theta),
                        z
                    );
                }

                // Create faces (each trapezoid split into two triangles)
                for (let i = 0; i < 10; i++) {
                    const topCurrent = i;
                    const topNext = (i + 1) % 10;
                    const bottomCurrent = i + 10;
                    const bottomNext = ((i + 1) % 10) + 10;

                    // First triangle of the trapezoid
                    indices.push(topCurrent, bottomCurrent, topNext);

                    // Second triangle of the trapezoid
                    indices.push(topNext, bottomCurrent, bottomNext);
                }

                // Simple UV mapping (this may need refinement for better texture alignment)
                for (let i = 0; i < indices.length; i += 3) {
                    uvs.push(
                        0.5, 1,
                        0, 0,
                        1, 0
                    );
                }

                geometry.setIndex(indices);
                geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(vertices), 3));
                geometry.setAttribute('uv', new THREE.BufferAttribute(new Float32Array(uvs.flat()), 2));
                geometry.computeVertexNormals();

                return geometry;
            }

            /**
             * Create custom geometry for D12 dice (dodecahedron)
             * @returns {THREE.DodecahedronGeometry} - The D12 geometry
             */
            createD12Geometry() {
                return new THREE.DodecahedronGeometry(1);
            }

            /**
             * Create custom geometry for D20 dice (icosahedron)
             * @returns {THREE.IcosahedronGeometry} - The D20 geometry
             */
            createD20Geometry() {
                return new THREE.IcosahedronGeometry(1);
            }

            /**
             * Create custom geometry for D100 dice (subdivided icosahedron)
             * @returns {THREE.IcosahedronGeometry} - The D100 geometry
             */
            createD100Geometry() {
                // D100 is complex; using a subdivided Icosahedron for demonstration
                return new THREE.IcosahedronGeometry(1, 2); // Subdivided icosahedron
            }

            /**
             * Initialize drag functionality for the panel
             */
            initDragGrip() {
                const dragGrip = this.shadowRoot.getElementById('drag-grip');
                const panel = this.shadowRoot.getElementById('dice-container');
                let isDragging = false;
                let initialMousePosition = { x: 0, y: 0 };
                let initialPanelPosition = { x: 0, y: 0 };

                // Ensure the panel is positioned absolutely so that dragging works
                panel.style.position = 'absolute';

                // Handle mousedown event to start dragging
                dragGrip.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    initialMousePosition.x = e.clientX;
                    initialMousePosition.y = e.clientY;
                    initialPanelPosition.x = panel.offsetLeft;
                    initialPanelPosition.y = panel.offsetTop;

                    // Prevent text selection while dragging
                    e.preventDefault();
                });

                // Handle mousemove event for dragging
                const onMouseMove = (e) => {
                    if (!isDragging) return;

                    const deltaX = e.clientX - initialMousePosition.x;
                    const deltaY = e.clientY - initialMousePosition.y;
                    const newX = initialPanelPosition.x + deltaX;
                    const newY = initialPanelPosition.y + deltaY;

                    panel.style.left = `${newX}px`;
                    panel.style.top = `${newY}px`;
                };

                // Handle mouseup event to stop dragging
                const onMouseUp = () => {
                    if (isDragging) {
                        isDragging = false;
                    }
                };

                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            }

            /**
             * Close the dice roller panel
             */
            closePanel() {
                this.container.classList.add('fade-in');
                this.container.style.display = 'none';
            }

            /**
             * Minimize the dice roller panel
             */
            minimizePanel() {
                const webglOutput = this.shadowRoot.getElementById('webgl-output');
                const diceControls = this.shadowRoot.getElementById('dice-controls');
                const result = this.shadowRoot.getElementById('result');

                // Toggle visibility
                const isHidden = webglOutput.style.display === 'none';
                webglOutput.style.display = isHidden ? 'block' : 'none';
                diceControls.style.display = isHidden ? 'block' : 'none';
                result.style.display = isHidden ? 'block' : 'none';
            }

            /**
             * Maximize the dice roller panel
             */
            maximizePanel() {
                const panel = this.shadowRoot.getElementById('dice-container');
                const isMaximized = panel.classList.contains('maximized');

                if (isMaximized) {
                    // Restore to original size
                    panel.style.width = '650px';
                    panel.style.height = 'auto';
                    panel.classList.remove('maximized');
                } else {
                    // Maximize
                    panel.style.width = '100%';
                    panel.style.height = '100%';
                    panel.classList.add('maximized');
                }
            }
        }

        customElements.define('dice-roller', DiceRoller);


        customElements.define('drag-grip', DragGrip);


    </script>
    <slider-puzzle id="slider-panel" draggable="true"></slider-puzzle>


    <script>
        class SliderPuzzle extends HTMLElement {
            constructor() {
                super();
                this.attachShadow({ mode: 'open' });
                this.puzzleState = {
                    size: 4, // Default puzzle size (4x4)
                    tiles: [],
                    tilePositions: [],
                    moveCount: 0,
                    estimatedMinimumMoves: 0,
                    timerStart: null,
                    timerInterval: null,
                    timerRunning: false,
                    imageUrl: null,
                };
                this.render();
            }

            connectedCallback() {
                this.loadDefaultImage();
            }

            disconnectedCallback() {
                this.stopTimer();
            }

            // Render the component's HTML and CSS
            render() {
                const style = document.createElement('style');
                style.textContent = `
                    :host {
                        display: block;
                        font-family: Arial, sans-serif;
                        background-color: #f0f0f0;
                        text-align: center;
                        width: 100%;
                        max-width: 700px;
                        margin: 20px auto;
                        color: black;
                        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
                        border-radius: 10px;
                        padding: 20px;
                        box-sizing: border-box;
                    }

                    #controls {
                        display: flex;
                        flex-wrap: wrap;
                        justify-content: center;
                        gap: 10px;
                        margin-bottom: 20px;
                    }

                    button, select, input[type="file"] {
                        padding: 10px 15px;
                        font-size: 16px;
                        cursor: pointer;
                        border: none;
                        border-radius: 5px;
                        background-color: #3498db;
                        color: white;
                        transition: background-color 0.2s;
                    }

                    button:hover, select:hover, input[type="file"]:hover {
                        background-color: #2980b9;
                    }

                    #timer, #moveCount {
                        margin: 10px;
                        font-size: 18px;
                    }

                    #moveCount.optimal {
                        color: green;
                    }

                    #moveCount.good {
                        color: orange;
                    }

                    #moveCount.needs-improvement {
                        color: red;
                    }

                    #ogimage {
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        padding: 10px;
                        background-color: limegreen;
                        color: white;
                        border-radius: 5px;
                        cursor: pointer;
                        transition: background-color 0.2s;
                        margin-bottom: 10px;
                        user-select: none;
                    }

                    #ogimage.active {
                        background-color: darkgreen;
                    }

                    #ogimg {
                        display: none;
                        max-width: 100%;
                        max-height: 300px;
                        margin: 10px auto;
                        border: 2px solid #2980b9;
                        border-radius: 5px;
                    }

                    #puzzleGrid {
                        display: grid;
                        gap: 2px;
                        margin: 0 auto;
                        width: 100%;
                        max-width: 600px;
                        border: 2px solid #2980b9;
                        border-radius: 10px;
                        overflow: hidden;
                        background-color: #fff;
                    }

                    .tile {
                        background-size: cover;
                        background-position: center;
                        cursor: pointer;
                        aspect-ratio: 1 / 1;
                        transition: transform 0.2s;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        font-size: 24px;
                        font-weight: bold;
                        color: transparent;
                        user-select: none;
                    }

                    .tile:hover {
                        transform: scale(0.98);
                        box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
                    }

                    .hidden {
                        visibility: hidden;
                        cursor: default;
                    }

                    /* Responsive Design */
                    @media (max-width: 600px) {
                        #puzzleGrid {
                            max-width: 90vw;
                        }
                    }
                `;

                const template = document.createElement('div');
                template.innerHTML = `
                    <div id="ogimage" tabindex="0" aria-label="Toggle Original Image">HINT</div>
                    <img id="ogimg" alt="Original Image" />
                    
                    <div id="controls">
                        <button id="shuffleButton">Shuffle</button>
                        <button id="resetButton">Reset</button>
                        <input type="file" id="uploadButton" accept="image/*" aria-label="Upload Image">
                        <label for="puzzleSize" style="display: flex; align-items: center; gap: 5px;">
                            Size:
                            <select name="puzzleSize" id="puzzleSize" aria-label="Select Puzzle Size">
                                <option value="3">3 x 3</option>
                                <option value="4" selected>4 x 4</option>
                                <option value="5">5 x 5</option>
                            </select>
                        </label>
                    </div>
                    
                    <div id="timer">Elapsed Time: 00:00</div>
                    <div id="moveCount">Moves Made: 0</div>
                    
                    <div id="puzzleGrid" aria-label="Puzzle Grid"></div>
                `;

                this.shadowRoot.appendChild(style);
                this.shadowRoot.appendChild(template);

                this.bindEvents();
            }

            // Bind event listeners to controls and interactive elements
            bindEvents() {
                const shadow = this.shadowRoot;

                shadow.getElementById('shuffleButton').addEventListener('click', () => this.shufflePuzzle());
                shadow.getElementById('resetButton').addEventListener('click', () => this.resetPuzzle());
                shadow.getElementById('uploadButton').addEventListener('change', (e) => this.handleImageUpload(e));
                shadow.getElementById('puzzleSize').addEventListener('change', () => this.changePuzzleSize());
                shadow.getElementById('ogimage').addEventListener('click', () => this.toggleOriginalImage());

                // Accessibility: Allow toggling original image via keyboard
                shadow.getElementById('ogimage').addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        this.toggleOriginalImage();
                    }
                });
            }

            // Initialize tiles based on current size and image
            initializeTiles() {
                const totalTiles = this.puzzleState.size * this.puzzleState.size;
                this.puzzleState.tiles = [];
                this.puzzleState.tilePositions = [];

                for (let i = 1; i < totalTiles; i++) {
                    this.puzzleState.tiles.push(i);
                    this.puzzleState.tilePositions.push(i);
                }
                this.puzzleState.tilePositions.push(0); // Empty tile
            }

            // Update the grid layout based on puzzle size
            updateGridStyle() {
                const puzzleGrid = this.shadowRoot.getElementById('puzzleGrid');
                puzzleGrid.style.gridTemplateColumns = `repeat(${this.puzzleState.size}, 1fr)`;
                puzzleGrid.style.gridTemplateRows = `repeat(${this.puzzleState.size}, 1fr)`;
            }

            // Render the puzzle grid based on current tile positions
            initializePuzzle() {
                const puzzleGrid = this.shadowRoot.getElementById('puzzleGrid');
                puzzleGrid.innerHTML = '';
                this.updateGridStyle();

                this.puzzleState.tilePositions.forEach((value, index) => {
                    const tile = document.createElement('div');
                    tile.classList.add('tile');
                    tile.setAttribute('role', 'button');
                    tile.setAttribute('aria-label', value === 0 ? 'Empty Tile' : `Tile ${value}`);
                    tile.setAttribute('tabindex', value === 0 ? '-1' : '0');

                    if (value === 0) {
                        tile.classList.add('hidden');
                    } else {
                        const row = Math.floor((value - 1) / this.puzzleState.size);
                        const col = (value - 1) % this.puzzleState.size;
                        tile.style.backgroundImage = `url(${this.puzzleState.imageUrl})`;
                        tile.style.backgroundSize = `${this.puzzleState.size * 100}% ${this.puzzleState.size * 100}%`;
                        tile.style.backgroundPosition = `${(col * 100) / (this.puzzleState.size - 1)}% ${(row * 100) / (this.puzzleState.size - 1)}%`;
                        tile.textContent = value; // Optional: Display tile number for debugging
                        
                        // Keyboard accessibility: Allow tile movement via Enter or Space
                        tile.addEventListener('keydown', (e) => {
                            if (e.key === 'Enter' || e.key === ' ') {
                                e.preventDefault();
                                this.moveTile(index);
                            }
                        });
                    }

                    // Click event for tile movement
                    tile.addEventListener('click', () => this.moveTile(index));
                    puzzleGrid.appendChild(tile);
                });

                this.updateMoveCountDisplay();
            }

            // Handle tile movement logic
            moveTile(index) {
                const emptyIndex = this.puzzleState.tilePositions.indexOf(0);
                const size = this.puzzleState.size;

                const rowEmpty = Math.floor(emptyIndex / size);
                const colEmpty = emptyIndex % size;
                const rowTile = Math.floor(index / size);
                const colTile = index % size;

                const rowDiff = Math.abs(rowTile - rowEmpty);
                const colDiff = Math.abs(colTile - colEmpty);

                // Allow only adjacent moves (up, down, left, right)
                if ((rowDiff === 1 && colDiff === 0) || (rowDiff === 0 && colDiff === 1)) {
                    [this.puzzleState.tilePositions[index], this.puzzleState.tilePositions[emptyIndex]] = [this.puzzleState.tilePositions[emptyIndex], this.puzzleState.tilePositions[index]];
                    this.puzzleState.moveCount++;
                    this.initializePuzzle();
                    this.updateMoveCountDisplay();
                    this.checkWinCondition();
                } else {
                    // Optional: Provide feedback for invalid moves
                    // For example, shake the tile or display a message
                    console.log("Invalid move");
                }
            }

            // Shuffle the puzzle ensuring it's solvable
            shufflePuzzle() {
                do {
                    for (let i = this.puzzleState.tilePositions.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [this.puzzleState.tilePositions[i], this.puzzleState.tilePositions[j]] = [this.puzzleState.tilePositions[j], this.puzzleState.tilePositions[i]];
                    }
                } while (!this.isSolvable() || this.isSolved());

                this.initializePuzzle();
                this.puzzleState.moveCount = 0;
                this.calculateEstimatedMinimumMoves();
                this.updateMoveCountDisplay();
                this.resetTimer();
            }

            // Reset the puzzle to the initial state
            resetPuzzle() {
                this.puzzleState.tilePositions = [...this.puzzleState.tiles];
                this.initializePuzzle();
                this.puzzleState.moveCount = 0;
                this.updateMoveCountDisplay();
                this.resetTimer();
            }

            // Check if the current puzzle state is solvable
            isSolvable() {
                const inversionCount = this.getInversionCount(this.puzzleState.tilePositions);
                const size = this.puzzleState.size;
                if (size % 2 !== 0) {
                    return inversionCount % 2 === 0;
                } else {
                    const emptyRow = Math.floor(this.puzzleState.tilePositions.indexOf(0) / size);
                    return (inversionCount + emptyRow) % 2 !== 0;
                }
            }

            // Calculate the number of inversions in the puzzle
            getInversionCount(arr) {
                let invCount = 0;
                const tiles = arr.filter(n => n !== 0);
                for (let i = 0; i < tiles.length - 1; i++) {
                    for (let j = i + 1; j < tiles.length; j++) {
                        if (tiles[i] > tiles[j]) {
                            invCount++;
                        }
                    }
                }
                return invCount;
            }

            // Check if the puzzle is solved
            isSolved() {
                for (let i = 0; i < this.puzzleState.tilePositions.length - 1; i++) {
                    if (this.puzzleState.tilePositions[i] !== i + 1) {
                        return false;
                    }
                }
                return true;
            }

            // Check for win condition and handle accordingly
            checkWinCondition() {
                if (this.isSolved()) {
                    this.stopTimer();
                    const efficiencyStatus = this.getEfficiencyStatus();
                    let efficiencyMessage = '';
                    if (efficiencyStatus === 'optimal') {
                        efficiencyMessage = 'Excellent! You solved the puzzle optimally.';
                    } else if (efficiencyStatus === 'good') {
                        efficiencyMessage = 'Great job! You solved the puzzle efficiently.';
                    } else {
                        efficiencyMessage = 'Good effort! Try solving it in fewer moves next time.';
                    }
                    alert(`üéâ Congratulations! You solved the puzzle in ${this.formatTime(Date.now() - this.puzzleState.timerStart)}!\n${efficiencyMessage}`);
                    
                    // Dispatch a custom event for puzzle completion
                    this.dispatchEvent(new CustomEvent('puzzle-completed', {
                        detail: {
                            time: this.formatTime(Date.now() - this.puzzleState.timerStart),
                            moves: this.puzzleState.moveCount,
                            efficiency: efficiencyStatus
                        }
                    }));
                }
            }

            // Start or reset the timer
            resetTimer() {
                this.stopTimer();
                this.puzzleState.timerStart = Date.now();
                this.puzzleState.timerRunning = true;
                this.updateTimerDisplay(0);
                this.puzzleState.timerInterval = setInterval(() => this.updateTimer(), 1000);
            }

            // Stop the timer
            stopTimer() {
                this.puzzleState.timerRunning = false;
                if (this.puzzleState.timerInterval) {
                    clearInterval(this.puzzleState.timerInterval);
                    this.puzzleState.timerInterval = null;
                }
            }

            // Update the timer display
            updateTimer() {
                if (this.puzzleState.timerRunning) {
                    const elapsed = Date.now() - this.puzzleState.timerStart;
                    this.updateTimerDisplay(elapsed);
                }
            }

            // Format time from milliseconds to MM:SS
            formatTime(ms) {
                const totalSeconds = Math.floor(ms / 1000);
                const minutes = String(Math.floor(totalSeconds / 60)).padStart(2, '0');
                const seconds = String(totalSeconds % 60).padStart(2, '0');
                return `${minutes}:${seconds}`;
            }

            // Update the timer element's text
            updateTimerDisplay(ms) {
                const timerElement = this.shadowRoot.getElementById('timer');
                timerElement.textContent = `Elapsed Time: ${this.formatTime(ms)}`;
            }

            // Calculate the estimated minimum number of moves using Manhattan Distance
            calculateEstimatedMinimumMoves() {
                let estimatedMoves = 0;
                const size = this.puzzleState.size;

                for (let i = 0; i < this.puzzleState.tilePositions.length; i++) {
                    const tileNumber = this.puzzleState.tilePositions[i];
                    if (tileNumber !== 0) {
                        const currentRow = Math.floor(i / size);
                        const currentCol = i % size;
                        const targetRow = Math.floor((tileNumber - 1) / size);
                        const targetCol = (tileNumber - 1) % size;
                        estimatedMoves += Math.abs(currentRow - targetRow) + Math.abs(currentCol - targetCol);
                    }
                }

                this.puzzleState.estimatedMinimumMoves = estimatedMoves;
            }

            // Update the move count display with efficiency feedback
            updateMoveCountDisplay() {
                const moveCountElement = this.shadowRoot.getElementById('moveCount');
                moveCountElement.textContent = `Moves Made: ${this.puzzleState.moveCount}`;

                // Remove existing efficiency classes
                moveCountElement.classList.remove('optimal', 'good', 'needs-improvement');

                // Add the current efficiency class
                const efficiencyStatus = this.getEfficiencyStatus();
                moveCountElement.classList.add(efficiencyStatus);
            }

            // Determine the efficiency status based on moves made vs estimated minimum
            getEfficiencyStatus() {
                const minMoves = this.puzzleState.estimatedMinimumMoves;
                const movesMade = this.puzzleState.moveCount;

                if (movesMade <= minMoves * 1.5) { // Adjust multiplier as needed
                    return 'optimal';
                } else if (movesMade <= minMoves * 3) {
                    return 'good';
                } else {
                    return 'needs-improvement';
                }
            }

            // Load the default image for the puzzle
            loadDefaultImage() {
                this.puzzleState.imageUrl = 'https://picsum.photos/600';
                this.shadowRoot.getElementById('ogimg').src = this.puzzleState.imageUrl;
                this.initializeTiles();
                this.initializePuzzle();
                this.resetTimer();
            }

            // Handle image upload by the user
            handleImageUpload(event) {
                const file = event.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        this.puzzleState.imageUrl = e.target.result;
                        this.shadowRoot.getElementById('ogimg').src = this.puzzleState.imageUrl;
                        this.initializeTiles();
                        this.initializePuzzle();
                        this.resetTimer();
                    };
                    reader.readAsDataURL(file);
                }
            }

            // Change the puzzle size based on user selection
            changePuzzleSize() {
                const selectedSize = parseInt(this.shadowRoot.getElementById('puzzleSize').value);
                if ([3, 4, 5].includes(selectedSize)) {
                    this.puzzleState.size = selectedSize;
                    this.initializeTiles();
                    this.initializePuzzle();
                    this.resetTimer();
                }
            }

            // Toggle the display of the original image hint
            toggleOriginalImage() {
                const ogimg = this.shadowRoot.getElementById('ogimg');
                const ogimage = this.shadowRoot.getElementById('ogimage');
                const isActive = ogimage.classList.toggle('active');
                ogimg.style.display = isActive ? 'block' : 'none';
            }
        }

        // Define the custom element
        customElements.define('slider-puzzle', SliderPuzzle);
        </script>


</body>

</html>
